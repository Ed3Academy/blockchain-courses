# 和你的代币交互

## 📒 区块链上的 API 文档

真棒。我们成功了。我们已经部署了我们的网站和合约并且已经成功连接了钱包。现在我们需要从网站上使用 Metamask 获得的凭证来实际调用我们的合约。

因此，我们的智能合约有这样的功能，可以获取到某个用户的余额。

```solidity
    function balanceOf(address account) view public returns (uint) {
        return balances[account];
    }
```

让我们从我们的网站上调用这个功能。

首先，就像我们在 Web 2 中前端开发需要知道后端 API 的格式、参数等信息一样，我们与区块链交互也需要这样的信息！

还记得我们编译后生成的 `artifacts` 文件夹吗？它就蕴含着我们所需要的文件。这类文件也叫作 ABI。

我们先新建一个 `abi` 文件夹在 `my-token-portal`下。然后我们将 `my-token` 项目中的 `artifacts\contracts\MyToken.sol\MyToken.json` 拷贝至 `abi` 文件夹中。

然后我们在 `index.tsx` 中导入 abi 文件

```tsx
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import MyTokenABI from "../abi/MyToken.json";

const abi = MyTokenABI.abi;

const Home = () => {
```

## 🏠 设置你的合约地址

还记得你在 Mumbai Testnet 上部署你的合约吗？那次部署的输出包括你的智能合约地址，看起来应该是这样的。

```none
Deploying contracts with account:  0x9f773d11C3eABb67Bd1827a983641b37c6C6B0a5
Account balance:  200000000000000000
MyToken address:  0xe7eF8d5C50fD89AaFF85384D50774aB15f0652FC
```

你需要在你的 React 应用程序中获得这个访问权。这很简单，只要在你的`index.tsx`文件中创建一个名为`contractAddress`的新属性。

```tsx
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import MyTokenABI from "../abi/MyToken.json";

const abi = MyTokenABI.abi;
const contractAddress = '0xe7eF8d5C50fD89AaFF85384D50774aB15f0652FC';

const Home = () => {
```

## 📒 读取数据

我们可以通过 wagmi 的 `useContractRead` 来读取数据

```tsx
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import MyTokenABI from "../abi/MyToken.json";
import { useContractRead, useAccount } from "wagmi";
import { useState, useEffect } from "react";

const abi = MyTokenABI.abi;
const contractAddress = "0xe7eF8d5C50fD89AaFF85384D50774aB15f0652FC";

const Home = () => {
  const { address } = useAccount();
  const [mounted, setMounted] = useState(false);

  const { data: balance } = useContractRead({
    address: contractAddress,
    abi,
    functionName: "balanceOf",
    args: [address],
  });

  const { data: totalSupply } = useContractRead({
    address: contractAddress,
    abi,
    functionName: "totalSupply",
  });

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  return (
    <div className={styles.container}>
      <Head>
        <title>My Token Portal</title>
        <meta
          name="description"
          content="Generated by @rainbow-me/create-rainbowkit"
        />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <ConnectButton />
        <h2>My Token</h2>
        <div className={styles.card}>
          <div>Balance</div>
          {balance && <div>{Number(balance)}</div>}
        </div>
        <div className={styles.card}>
          <div>Total Supply</div>
          {totalSupply && <div>{Number(totalSupply)}</div>}
        </div>
        <div className={styles.card}>
          <div>Mint</div>
          <div></div>
        </div>
      </main>
    </div>
  );
};

export default Home;
```

## 📝 写入数据

向我们的合约写数据的代码与读数据没有超级大的区别。主要的区别是，当我们想向合约写入新的数据时，我们需要通知矿工，以便交易可以被开采。当我们读取数据时，我们不需要这样做。读取是 "免费 "的，因为我们所做的只是从区块链上读取，**我们没有改变它。**

下面是 mint 的代码：

我们在 `mounted` 完成前添加以下代码

```tsx
const { config } = usePrepareContractWrite({
  address: contractAddress,
  abi,
  functionName: "mint",
});
const { data, write: mint } = useContractWrite(config);
const { isError, isLoading, isSuccess } = useWaitForTransaction({
  hash: data?.hash,
});

useEffect(() => {
  setMounted(true);
}, []);
```

首先，我们需要通过 `usePrepareContractWrite`函数 来获取write函数所需要的配置参数。这里我们指定了合约地址、ABI以及要调用的方法名。

接着，我们将配置传入 `useContractWrite` 就可以获得区块链可识别的交易数据 `data`。

再通过 `useWaitForTransaction`函数 即可完成调用。

我们还要在 mint 卡片中添加按钮以便完成 mint 调用

```tsx
<div className={styles.card}>
  <div>Mint</div>
  <div>
    <button
      onClick={() => {
        mint?.();
      }}
    >
      Confirm
    </button>
  </div>
  {isSuccess && <div>Mint success</div>}
  {isError && <div>Mint error</div>}
</div>
```

很简单，对吧 :)?

这里最棒的是，当交易被挖出时，你实际上可以打印出交易哈希值，将其复制/粘贴到 [Mumbai Polygonscan](https://mumbai.polygonscan.com/), 并看到它正在被实时处理 :)。

当我们运行这个时，你会看到 Metamask 弹出并要求我们支付 "Gas"，我们用我们的假美元支付。 有一篇关于它的很好的文章[这里](https://ethereum.org/en/developers/docs/gas/). 试着弄清楚什么是 Gas:)。

我们刷新页面会发现 balance 和 supply 也增加了！

## 🎉 成功

真是一个好东西！我们现在有一个实际的客户端，可以读取和写入区块链的数据。从这里，你可以做任何你想做的事情。你已经有了基本的东西了。你可以建立一个去中心化的 Twitter 版本。你可以建立一种方式，让人们发布他们最喜欢的备忘录，并允许人们用 ETH 给发布最佳备忘录的人 "打赏"。你可以建立一个去中心化的投票系统，一个国家可以用它来投票选举一个政治家，在那里一切都公开而清晰。

可能性确实是无穷无尽的。
