# 和你的合约交互

## 📒 获取合约 ABI

就像我们在传统前端开发中，需要知道后端 API 的 url、参数等信息一样，我们与区块链交互也需要这样的信息！

还记得我们的合约编译后生成的 `artifacts` 文件夹吗？它就蕴含着我们所需要的文件，这类文件也叫作 ABI。

我们先新建一个 `abi` 文件夹在前端项目根目录下，然后我们将合约项目中的 `artifacts\contracts\MyToken.sol\MyToken.json` 拷贝至 `abi` 文件夹中。

![abi.png](https://i.postimg.cc/BvdL9CsW/abi.png)

然后我们在 `index.jsx` 中导入 abi 文件：

```tsx
// ...
import { Card, Row, Col, Button, Typography } from "antd";
import ABI_GATE from "../abi/AirlineGate.json";
import ABI_TICKET from "../abi/TicketNft.json";
import ABI_POINT from "../abi/LoyaltyPoints.json";
import ABI_COUPON from "../abi/Coupon.json";

const { Title } = Typography;
// ...
```

## 🏠 获取合约地址

还记得你在 Mumbai Testnet 上部署的合约吗？那次部署的输出包括你的智能合约地址，看起来应该是这样的。

```none
Deploying contracts with account:  0x9f773d11C3eABb67Bd1827a983641b37c6C6B0a5
Account balance:  200000000000000000
MyToken address:  0xe7eF8d5C50fD89AaFF85384D50774aB15f0652FC
```

前端项目中需要知道合约地址，才能与合约进行交互。那么我们在 `index.jsx `中声明几个常量：

```tsx
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import MyTokenABI from "../abi/MyToken.json";

const abi = MyTokenABI.abi;
const contractAddress = '0xe7eF8d5C50fD89AaFF85384D50774aB15f0652FC';

const Home = () => {
```

## 📒 读取数据

我们可以通过 wagmi 的 `useContractRead` 来读取数据

```tsx
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import MyTokenABI from "../abi/MyToken.json";
import { useContractRead, useAccount } from "wagmi";
import { useState, useEffect } from "react";
import { BigNumber } from "ethers";

const abi = MyTokenABI.abi;
const contractAddress = "0xe7eF8d5C50fD89AaFF85384D50774aB15f0652FC";

const Home = () => {
  const { address } = useAccount();
  const [mounted, setMounted] = useState(false);

  const { data: balance } = useContractRead<
    typeof abi,
    "balanceOf",
    number | BigNumber | undefined
  >({
    address: contractAddress,
    abi,
    functionName: "balanceOf",
    args: [address],
  });

  const { data: totalSupply } = useContractRead<
    typeof abi,
    "totalSupply",
    number | BigNumber | undefined
  >({
    address: contractAddress,
    abi,
    functionName: "totalSupply",
  });

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  return (
    <div className={styles.container}>
      <Head>
        <title>My Token Portal</title>
        <meta
          name="description"
          content="Generated by @rainbow-me/create-rainbowkit"
        />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <ConnectButton />
        <h2>My Token</h2>
        <div className={styles.card}>
          <div>Balance</div>
          {balance && <div>{balance.toString()}</div>}
        </div>
        <div className={styles.card}>
          <div>Total Supply</div>
          {totalSupply && <div>{totalSupply.toString()}</div>}
        </div>
        <div className={styles.card}>
          <div>Mint</div>
          <div></div>
        </div>
      </main>
    </div>
  );
};

export default Home;
```

这样一来我们的页面就显示出了Balance和Total Supply

![screenshot](https://live.staticflickr.com/65535/52752408831_9857174404.jpg)

在 `useContractRead` 后的 `<>` 中我们指定了一些类型（包括返回值）

## 📝 写入数据

向我们的合约写数据的代码与读数据没有超级大的区别。主要的区别是，当我们想向合约写入新的数据时，我们需要通知矿工，以便交易可以被开采。当我们读取数据时，我们不需要这样做。读取是 "免费 "的，因为我们所做的只是从区块链上读取，**我们没有改变它。**

下面是 mint 的代码：

我们在 `mounted` 完成前添加以下代码

```tsx
const { config } = usePrepareContractWrite({
  address: contractAddress,
  abi,
  functionName: "mint",
});
const { data, write: mint } = useContractWrite(config);
const { isError, isLoading, isSuccess } = useWaitForTransaction({
  hash: data?.hash,
});

useEffect(() => {
  setMounted(true);
}, []);
```

首先，我们需要通过 `usePrepareContractWrite`函数 来获取write函数所需要的配置参数。这里我们指定了合约地址、ABI以及要调用的方法名。

接着，我们将配置传入 `useContractWrite` 就可以获得区块链可识别的交易数据 `data`。

再通过 `useWaitForTransaction`函数 即可完成调用。

我们还要在 mint 卡片中添加按钮以便完成 mint 调用

```tsx
<div className={styles.card}>
  <div>Mint</div>
  <div>
    <button
      onClick={() => {
        mint?.();
      }}
    >
      Confirm
    </button>
  </div>
  {isSuccess && <div>Mint success</div>}
  {isError && <div>Mint error</div>}
</div>
```

很简单，对吧 :)?

这里最棒的是，当交易被挖出时，你实际上可以打印出交易哈希值，将其复制/粘贴到 [Mumbai Polygonscan](https://mumbai.polygonscan.com/), 并看到它正在被实时处理 :)。

当我们运行这个时，你会看到 Metamask 弹出并要求我们支付 "Gas"，我们用我们的假美元支付。 有一篇关于它的很好的文章[这里](https://ethereum.org/en/developers/docs/gas/). 试着弄清楚什么是 Gas:)。

我们刷新页面会发现 balance 和 supply 也增加了！

## 🎉 成功

真是一个好东西！我们现在有一个实际的客户端，可以读取和写入区块链的数据。从这里，你可以做任何你想做的事情。你已经有了基本的东西了。你可以建立一个去中心化的 Twitter 版本。你可以建立一种方式，让人们发布他们最喜欢的备忘录，并允许人们用 ETH 给发布最佳备忘录的人 "打赏"。你可以建立一个去中心化的投票系统，一个国家可以用它来投票选举一个政治家，在那里一切都公开而清晰。

可能性确实是无穷无尽的。
